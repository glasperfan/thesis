from helpers import * # includes music21
import math
import time
import sys
import os
from ordered_set import OrderedSet
from glob import glob
from random import shuffle
import numpy as npy
import h5py

#####
#
# data.py
#
# Goal: create a data representation of the entire Bach chorale set - that is, the 371 chorales 
# contained in the Riemenschieder edition.
# 
# Each chorale is quantiized to quarter notes, and then each beat reprsents a training example.
#
# Input data contains melody note a time t. Features include score-wide properties like key and time,
# as well as beat-specific information such as beat strength, offset from the end of the chorale, distance to
# the next cadence, whether a cadence occurs on that beat, and the melodic interval before and after the 
# current melody pitch.
#
# There are output datasets from the following properties:
# - Roman numerals ('I', 'bVII')
# - Inversions ('[root]', '6', '65', '42')
# - Alto voice (MIDI note in the alto range)
# - Tenor voice (MIDI note in the tenor range)
#
#
#
#
#
#
#
#####


##########################
# General helper functions
##########################

# Split a list randomly into two lists with a proportion of [pg : 1 - pg]
def split(lst, pg):
		shuffle(lst)
		split_point = int(len(lst) * pg)
		set1 = lst[:split_point]
		set2 = lst[split_point:]
		for s in set1:
			for t in set2:
				assert not npy.array_equal(s, t)
		return set1, set2

def _contains(s, seq):
	for c in seq:
		if c not in s:
			return False
	return True

# Use the @timing decorator to determine how long the function takes to run.
def timing(f):
    def wrap(*args):
        time1 = time.time()
        ret = f(*args)
        time2 = time.time()
        print '%s function took %0.3f s' % (f.func_name, (time2-time1))
        return ret
    return wrap


#############################
# Featurizer helper functions
#############################

# Featurize the harmony as a tuple (ATB) at time i
def feat_chord(i, a, t, b):
	return a[i].midi, t[i].midi, b[i].midi

# Featurize melodic motion as an interval (an integer representing the half steps between two pitches)
# If n1 is a lower pitch than n2, the interval will be a positive value, and vice versa.
def feat_interval(n1, n2):
	return n2.midi - n1.midi

# Featurize harmony (s, a, t, and b are notes, while 'key_sig' is a key signature object)
def feat_harmony(s, a, t, b, key_obj):
	voicing = [s,a,t,b]
	rn = roman.romanNumeralFromChord(chord.Chord([s,a,t,b]), key_obj)
	rn_fig = verify_harmony(rn, key_obj)
	return rn_fig

def get_extension(rn):
	return rn.figure[rn.figure.index(rn.romanNumeral) + len(rn.romanNumeral):]

# Manual correction of Roman numeral analysis
# Due to inconsistencies in the music21 RNA, some standard guidelines are established to simplify
# the harmonies generated by music21.roman.romanNumeralFromChord.
# In the event of an unrecognizable harmony, this function asks the user for guidance. This does occur occassionally,
# as chords appear that are difficult to properly harmonically analyze.
basicRomanNumerals = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'i', 'ii', 'iio' 'iii', 'iv', 'v', 'vi', 'vii', 'viio']
basicExtensions = ['', '6', '64', '7', 'b7', '65', '43', '42']
def verify_harmony(rn, key_obj):
	if not os.path.isfile("_frozen/harmony_dict.txt"):
		freezeObject({}, "harmony_dict")
	harmony_dict = thawObject("harmony_dict")
	if rn.figure not in harmony_dict:
		for idx in [1,2,3]:
			if rn.figure[:idx] in basicRomanNumerals and rn.figure[idx:] in basicExtensions:
				harmony_dict[rn.figure] = (rn.figure[:idx], rn.figure[idx:])
				return harmony_dict[rn.figure]
		inversion_changes = {('b7', '5', '3') : 'b7',
							 ('b7', '4', '3') : 'b743',
							 ('b7', '3') : 'b7',
							 ('b7', '6', '5') : 'b765',
							 ('b7', '4', '2') : 'b742',
							 '765': '65',
							 '742' : '2',
							 '753' : '7',
							 '73': '7',
							 '653' : '65', 
							 '643': '43',
							 '642' : '42',
							 '63' : '63',
							 '64' : '64', 
							 '532': '2', 
							 '54' : '4',
							 '42' : '42'}
		for inv, correct_inv in inversion_changes.items():
			if _contains(rn.figure, inv):
				rml = rn.romanNumeral + 'o' if 'o' in rn.figure else rn.romanNumeral
				rml = 'b' + rml[1:] if '-' in rn.romanNumeral else rml
				rml = 'VI' if rml == 'bVI' and key_obj.mode == 'minor' else rml
				harmony_dict[rn.figure] = (rml, correct_inv)
				freezeObject(harmony_dict, "harmony_dict")
				print "Added %s as %s." % (rn.figure, harmony_dict[rn.figure])
				return harmony_dict[rn.figure]
		print "The current figure is %s." % rn.figureAndKey
		print "The pitches are %s %s %s %s." % rn.pitches
		new_numeral = raw_input("What should the new roman numeral be?: ")
		new_extension = raw_input("What should the new extension be?: ")
		harmony_dict[rn.figure] = (new_numeral, new_extension)
		freezeObject(harmony_dict, "harmony_dict")
	return harmony_dict[rn.figure]








class Featurizer(object):
	#
	# Converts chorales into a matrix of feature indices. Each vector in a matrix represents a specific beat within
	# a chorale. Note that indices are 1-based to comply with Torch. 
	#

	# Initialize with the number of scores to analyze
	def __init__(self):
		self.percentage_train = 0.8 # percentage of scores to be in the test split
		self.percentage_dev = 0.5 	# percentage of the test set to be used a dev set
		self.data_dir = "raw_data/"
		self.output_dir = "data/"

		# Features
		self.keys = OrderedSet()
		self.modes = OrderedSet()
		self.times = OrderedSet()
		self.beats = OrderedSet()
		self.offsets = OrderedSet()
		self.cadence_dists = OrderedSet()
		self.cadences = OrderedSet()
		self.pitches = OrderedSet()
		self.intervals = OrderedSet()
		self.numerals = OrderedSet()
		self.inversions = OrderedSet()
		self.altos = OrderedSet()
		self.tenors = OrderedSet()

		# THIS ORDER MATTERS
		self.input_features = [self.keys, self.modes, self.times, self.beats, self.offsets, self.cadence_dists, \
							self.cadences, self.pitches, self.intervals, self.intervals, self.numerals, self.inversions]
		self.output_features = [self.numerals, self.inversions, self.altos, self.tenors]

	# Collect all preprocessed scores
	@timing
	def gather_scores(self):
		from os import listdir
		self.original = []
		for f in glob(self.data_dir + "*.xml"):
			self.original.append(converter.parse(f))
		print "Gathered %d 4-part chorales." % len(self.original)
		
		return self.original

	# Create X and y matrices of features for each chorale
	@timing
	def analyze(self):
		print "Analyzing..."
		self.analyzed = [] # to save time, we store the related objects to a score for featurizing
		Xvalues, yvalues = [], []

		# Create X and y matrices for each chorale
		for idx, score in enumerate(self.original):
			sys.stdout.write("Analyzing #%d 	\r" % (idx + 1))
			sys.stdout.flush()
			# score-wide features
			S, A, T, B = getNotes(score.parts[0]), getNotes(score.parts[1]), getNotes(score.parts[2]), getNotes(score.parts[3])
			assert len(S) == len(A)
			assert len(A) == len(T)
			assert len(T) == len(B)
			time_sig, key_sig = getTimeSignature(score.parts[0]), getKeySignature(score.parts[0])
			key_obj = getKeyFromSignature(key_sig)
			fermata_locations = map(hasFermata, S)

			# Input/target data for each chorale
			Xc, yc = [], []

			# Create X vector and y output
			for index, n in enumerate(S):
				# [0]: Key
				v_key = key_sig.sharps
				self.keys.add(v_key)
				# [1]: Mode
				v_mode = key_sig.mode
				self.modes.add(v_mode)
				# [2]: Time
				v_time = (time_sig.numerator, time_sig.denominator)
				self.times.add(v_time)
				# [3]: Beat strength
				v_beat = n.beatStrength
				self.beats.add(n.beatStrength)
				# [4]: Offset end
				v_off_end = int(math.floor((len(S) - index) / 4.))
				self.offsets.add(v_off_end)
				# [5]: Cadence distance
				v_cadence_dist = 0 if hasFermata(n) else fermata_locations[index:].index(True)
				self.cadence_dists.add(v_cadence_dist)
				# [6]: Is a point of cadence
				v_cadence = 1 if hasFermata(n) else 0
				self.cadences.add(v_cadence)
				# [7]: Pitch
				v_pitch = n.midi
				self.pitches.add(v_pitch)
				# [8]: Interval to previous melody note
				v_ibefore = S[index].midi - S[index - 1].midi if index > 0 else 'None'
				self.intervals.add(v_ibefore)
				# [9]: Interval to next melody note
				v_iafter = S[index + 1].midi - S[index].midi if index < len(S) - 1 else 'None'
				self.intervals.add(v_iafter)
				# [10]: Numeral at time t-1
				# [11]: Inversion at time t-1
				timetminus1 = yc[-1] if len(yc) > 0 else ('None', 'None')
				v_num_prev = timetminus1[0] # Roman numeral
				v_inv_prev = timetminus1[1] # inversion
				# Intentionally not adding this self.numerals and self.inversions
				
				# Output vector
				# [0]: numeral
				# [1]: inversion
				v_num, v_inv = feat_harmony(S[index - 1], A[index - 1], T[index - 1], B[index - 1], key_obj)
				self.numerals.add(v_num)
				self.inversions.add(v_inv)
				# [2]: alto pitch
				v_alto = A[index].midi
				self.altos.add(v_alto)
				# [3]: tenor pitch
				v_tenor = T[index].midi
				self.tenors.add(v_tenor)

				# Input vector
				input_vec = [v_key, v_mode, v_time, v_beat, v_off_end, v_cadence_dist, v_cadence, \
							 v_pitch, v_ibefore, v_iafter, v_num_prev, v_inv_prev]
				output_vec = [v_num, v_inv, v_alto, v_tenor]

				Xc.append(input_vec)
				yc.append(output_vec)

			self.analyzed.append((Xc, yc, score, idx))
			Xvalues.append(Xc)
			yvalues.append(yc)

		# Add the 'n/a' option
		self.numerals.add('None')
		self.inversions.add('None')
		self.intervals.add('None')

		freezeObject(Xvalues, 'Xvalues')
		freezeObject(yvalues, 'yvalues')
	
	# After calling self.analyze, this converts the X and y matrices to vectors of feature indices
	# As scores are examined, the indices of output chords are generated.
	@timing
	def featurize(self):
		print "Featurizing..."
		self.featurized = []

		# Set the indices
		self.input_indices = []
		max_index = 1
		for feature_space in self.input_features:
			self.input_indices.append((max_index, max_index + len(feature_space) - 1))
			max_index += len(feature_space)

		for Xc, yc, score, idx in self.analyzed:
			Xcf, ycf = [], []
			for vec in Xc:
				fvec = []
				for fidx, feature_space in enumerate(self.input_features):
					f_feature = feature_space.index(vec[fidx])
					fvec.append(f_feature + self.input_indices[fidx][0])
				Xcf.append(fvec)
			for vec in yc:
				fvec = []
				for fidx, feature_space in enumerate(self.output_features):
					fvec.append(feature_space.index(vec[fidx]) + 1)
				ycf.append(fvec)
			self.featurized.append((npy.matrix(Xcf), npy.matrix(ycf), score, idx))


	# Verify that the feature indices are all in the right ranges
	@timing
	def verify(self):
		print "Verifying indices..."
		for Xcf, ycf, score, idx in self.featurized:
			for fidx in range(Xcf.shape[1]):
				assert Xcf[:, fidx].min() >= self.input_indices[fidx][0]
				assert Xcf[:, fidx].max() <= self.input_indices[fidx][1]
				if fidx > 0:
					assert Xcf[:, fidx - 1].max() < Xcf[:, fidx].min() 
			for fidx in range(ycf.shape[1]):
				assert ycf[:, fidx].min() >= 1
				assert ycf[:, fidx].max() <= len(self.output_features[fidx])

	# Split the chorales into training, dev, and test groups
	@timing
	def train_test_split(self):
		self.train, remaining = split(self.featurized, self.percentage_train)
		self.dev, self.test = split(remaining, self.percentage_dev)
		print "Training, dev, and tests sets contain %d, %d, %d chorales, respectively." \
				% (len(self.train), len(self.dev), len(self.test))

	# Create the aggregate datasets
	@timing
	def aggregrate(self):
		stack = lambda x1, x2: npy.vstack((x1, x2))
		trainX, trainy = [x for (x, y, sc, idx) in self.train], [y for (x, y, sc, idx) in self.train]
		devX, devy = [x for (x, y, sc, idx) in self.dev], [y for (x, y, sc, idx) in self.dev]
		testX, testy = [x for (x, y, sc, idx) in self.test], [y for (x, y, sc, idx) in self.test]
		self.trainXall, self.trainyall = reduce(stack, trainX), reduce(stack, trainy)
		self.devXall, self.devyall = reduce(stack, devX), reduce(stack, devy)
		self.testXall, self.testyall = reduce(stack, testX), reduce(stack, testy)
		self.dataXall = stack(stack(self.trainXall, self.devXall), self.testXall)
		self.datayall = stack(stack(self.trainyall, self.devyall), self.testyall)

	# Write 
	@timing
	def write(self):
		print "Writing to %s folder." % self.output_dir
		with h5py.File(self.output_dir + "chorales.hdf5", "w", libver="latest") as f:
			f.create_dataset("Xtrain", self.trainXall.shape, dtype="i", data=self.trainXall)
			f.create_dataset("ytrain", self.trainyall.shape, dtype="i", data=self.trainyall)
			f.create_dataset("Xdev", self.devXall.shape, dtype="i", data=self.devXall)
			f.create_dataset("ydev", self.devyall.shape, dtype="i", data=self.devyall)
			f.create_dataset("Xtest", self.testXall.shape, dtype="i", data=self.testXall)
			f.create_dataset("ytest", self.testyall.shape, dtype="i", data=self.testyall)
			with open('data/chorale_index.txt', 'a') as m:
				for Xcf, ycf, score, idx in self.featurized:
					f.create_dataset("chorale%d_X" % idx, Xcf.shape, dtype="i", data=Xcf)
					f.create_dataset("chorale%d_y" % idx, ycf.shape, dtype="i", data=ycf)
					m.write("%d\t %s\n" % (idx, score.metadata.title))

		freezeObject(self.input_features, "input_features")
		freezeObject(self.input_indices, "input_indices")
		freezeObject(self.numerals, "numerals")
		freezeObject(self.inversions, "inversions")
		freezeObject(self.altos, "alto_range")
		freezeObject(self.tenors, "tenor_range")


	def run(self):
		self.gather_scores()
		self.analyze()
		self.featurize()
		self.verify()
		self.train_test_split()
		self.aggregrate()
		self.write()

	

sf = Featurizer()
sf.run()
